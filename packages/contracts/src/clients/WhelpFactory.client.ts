/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import {
  CosmWasmClient,
  SigningCosmWasmClient,
  ExecuteResult,
} from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import {
  Uint128,
  Decimal,
  PoolType,
  InstantiateMsg,
  DefaultStakeConfig,
  PoolConfig,
  FeeConfig,
  ExecuteMsg,
  AssetInfo,
  Binary,
  PartialDefaultStakeConfig,
  PartialStakeConfig,
  DistributionFlow,
  Cw20ReceiveMsg,
  QueryMsg,
  MigrateMsg,
  Asset,
  ArrayOfPoolType,
  Addr,
  ConfigResponse,
  FeeInfoResponse,
  AssetInfoValidated,
  PairInfo,
  PoolsResponse,
  ArrayOfAddr,
  Boolean,
} from "../types/WhelpFactory.types";
export interface WhelpFactoryReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<ConfigResponse>;
  pool: ({ assetInfos }: { assetInfos: AssetInfo[] }) => Promise<PairInfo>;
  pools: ({
    limit,
    startAfter,
  }: {
    limit?: number;
    startAfter?: AssetInfo[];
  }) => Promise<PoolsResponse>;
  feeInfo: ({ poolType }: { poolType: PoolType }) => Promise<FeeInfoResponse>;
  blacklistedPoolTypes: () => Promise<ArrayOfPoolType>;
  poolsToMigrate: () => Promise<ArrayOfAddr>;
  validateStakingAddress: ({
    address,
  }: {
    address: string;
  }) => Promise<Boolean>;
}
export class WhelpFactoryQueryClient implements WhelpFactoryReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.pool = this.pool.bind(this);
    this.pools = this.pools.bind(this);
    this.feeInfo = this.feeInfo.bind(this);
    this.blacklistedPoolTypes = this.blacklistedPoolTypes.bind(this);
    this.poolsToMigrate = this.poolsToMigrate.bind(this);
    this.validateStakingAddress = this.validateStakingAddress.bind(this);
  }

  config = async (): Promise<ConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {},
    });
  };
  pool = async ({
    assetInfos,
  }: {
    assetInfos: AssetInfo[];
  }): Promise<PairInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pool: {
        asset_infos: assetInfos,
      },
    });
  };
  pools = async ({
    limit,
    startAfter,
  }: {
    limit?: number;
    startAfter?: AssetInfo[];
  }): Promise<PoolsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pools: {
        limit,
        start_after: startAfter,
      },
    });
  };
  feeInfo = async ({
    poolType,
  }: {
    poolType: PoolType;
  }): Promise<FeeInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      fee_info: {
        pool_type: poolType,
      },
    });
  };
  blacklistedPoolTypes = async (): Promise<ArrayOfPoolType> => {
    return this.client.queryContractSmart(this.contractAddress, {
      blacklisted_pool_types: {},
    });
  };
  poolsToMigrate = async (): Promise<ArrayOfAddr> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pools_to_migrate: {},
    });
  };
  validateStakingAddress = async ({
    address,
  }: {
    address: string;
  }): Promise<Boolean> => {
    return this.client.queryContractSmart(this.contractAddress, {
      validate_staking_address: {
        address,
      },
    });
  };
}
export interface WhelpFactoryInterface extends WhelpFactoryReadOnlyInterface {
  contractAddress: string;
  sender: string;
  updateConfig: (
    {
      defaultStakeConfig,
      feeAddress,
      onlyOwnerCanCreatePools,
    }: {
      defaultStakeConfig?: PartialDefaultStakeConfig;
      feeAddress?: string;
      onlyOwnerCanCreatePools?: boolean;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  updatePoolConfig: (
    {
      config,
    }: {
      config: PoolConfig;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  createPool: (
    {
      assetInfos,
      initParams,
      poolType,
      stakingConfig,
      totalFeeBps,
    }: {
      assetInfos: AssetInfo[];
      initParams?: Binary;
      poolType: PoolType;
      stakingConfig?: PartialStakeConfig;
      totalFeeBps?: number;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  updatePoolFees: (
    {
      assetInfos,
      feeConfig,
    }: {
      assetInfos: AssetInfo[];
      feeConfig: FeeConfig;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  deregister: (
    {
      assetInfos,
    }: {
      assetInfos: AssetInfo[];
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  proposeNewOwner: (
    {
      expiresIn,
      owner,
    }: {
      expiresIn: number;
      owner: string;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  dropOwnershipProposal: (
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  claimOwnership: (
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  markAsMigrated: (
    {
      pools,
    }: {
      pools: string[];
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  createPoolAndDistributionFlows: (
    {
      assetInfos,
      distributionFlows,
      initParams,
      poolType,
      stakingConfig,
      totalFeeBps,
    }: {
      assetInfos: AssetInfo[];
      distributionFlows: DistributionFlow[];
      initParams?: Binary;
      poolType: PoolType;
      stakingConfig?: PartialStakeConfig;
      totalFeeBps?: number;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  createDistributionFlow: (
    {
      asset,
      assetInfos,
      rewards,
    }: {
      asset: AssetInfo;
      assetInfos: AssetInfo[];
      rewards: number[][];
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  receive: (
    {
      amount,
      msg,
      sender,
    }: {
      amount: Uint128;
      msg: Binary;
      sender: string;
    },
    fee?: number | StdFee | "auto",
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
}
export class WhelpFactoryClient
  extends WhelpFactoryQueryClient
  implements WhelpFactoryInterface
{
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(
    client: SigningCosmWasmClient,
    sender: string,
    contractAddress: string
  ) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.updateConfig = this.updateConfig.bind(this);
    this.updatePoolConfig = this.updatePoolConfig.bind(this);
    this.createPool = this.createPool.bind(this);
    this.updatePoolFees = this.updatePoolFees.bind(this);
    this.deregister = this.deregister.bind(this);
    this.proposeNewOwner = this.proposeNewOwner.bind(this);
    this.dropOwnershipProposal = this.dropOwnershipProposal.bind(this);
    this.claimOwnership = this.claimOwnership.bind(this);
    this.markAsMigrated = this.markAsMigrated.bind(this);
    this.createPoolAndDistributionFlows =
      this.createPoolAndDistributionFlows.bind(this);
    this.createDistributionFlow = this.createDistributionFlow.bind(this);
    this.receive = this.receive.bind(this);
  }

  updateConfig = async (
    {
      defaultStakeConfig,
      feeAddress,
      onlyOwnerCanCreatePools,
    }: {
      defaultStakeConfig?: PartialDefaultStakeConfig;
      feeAddress?: string;
      onlyOwnerCanCreatePools?: boolean;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_config: {
          default_stake_config: defaultStakeConfig,
          fee_address: feeAddress,
          only_owner_can_create_pools: onlyOwnerCanCreatePools,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  updatePoolConfig = async (
    {
      config,
    }: {
      config: PoolConfig;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_pool_config: {
          config,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  createPool = async (
    {
      assetInfos,
      initParams,
      poolType,
      stakingConfig,
      totalFeeBps,
    }: {
      assetInfos: AssetInfo[];
      initParams?: Binary;
      poolType: PoolType;
      stakingConfig?: PartialStakeConfig;
      totalFeeBps?: number;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        create_pool: {
          asset_infos: assetInfos,
          init_params: initParams,
          pool_type: poolType,
          staking_config: stakingConfig,
          total_fee_bps: totalFeeBps,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  updatePoolFees = async (
    {
      assetInfos,
      feeConfig,
    }: {
      assetInfos: AssetInfo[];
      feeConfig: FeeConfig;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_pool_fees: {
          asset_infos: assetInfos,
          fee_config: feeConfig,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  deregister = async (
    {
      assetInfos,
    }: {
      assetInfos: AssetInfo[];
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        deregister: {
          asset_infos: assetInfos,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  proposeNewOwner = async (
    {
      expiresIn,
      owner,
    }: {
      expiresIn: number;
      owner: string;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        propose_new_owner: {
          expires_in: expiresIn,
          owner,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  dropOwnershipProposal = async (
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        drop_ownership_proposal: {},
      },
      fee,
      memo,
      _funds
    );
  };
  claimOwnership = async (
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        claim_ownership: {},
      },
      fee,
      memo,
      _funds
    );
  };
  markAsMigrated = async (
    {
      pools,
    }: {
      pools: string[];
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        mark_as_migrated: {
          pools,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  createPoolAndDistributionFlows = async (
    {
      assetInfos,
      distributionFlows,
      initParams,
      poolType,
      stakingConfig,
      totalFeeBps,
    }: {
      assetInfos: AssetInfo[];
      distributionFlows: DistributionFlow[];
      initParams?: Binary;
      poolType: PoolType;
      stakingConfig?: PartialStakeConfig;
      totalFeeBps?: number;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        create_pool_and_distribution_flows: {
          asset_infos: assetInfos,
          distribution_flows: distributionFlows,
          init_params: initParams,
          pool_type: poolType,
          staking_config: stakingConfig,
          total_fee_bps: totalFeeBps,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  createDistributionFlow = async (
    {
      asset,
      assetInfos,
      rewards,
    }: {
      asset: AssetInfo;
      assetInfos: AssetInfo[];
      rewards: number[][];
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        create_distribution_flow: {
          asset,
          asset_infos: assetInfos,
          rewards,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  receive = async (
    {
      amount,
      msg,
      sender,
    }: {
      amount: Uint128;
      msg: Binary;
      sender: string;
    },
    fee: number | StdFee | "auto" = "auto",
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        receive: {
          amount,
          msg,
          sender,
        },
      },
      fee,
      memo,
      _funds
    );
  };
}
